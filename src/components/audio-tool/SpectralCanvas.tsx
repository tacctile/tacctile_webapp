/**
 * SpectralCanvas Component
 * Renders wavesurfer-generated spectrogram with Hz/dB scales and playhead
 */

import React, { useRef, useEffect, useCallback, useState } from 'react';
import Box from '@mui/material/Box';
import { usePlayheadStore } from '@/stores/usePlayheadStore';

interface SpectralCanvasProps {
  isLoaded: boolean;
  duration: number;
  zoom?: number;
  scrollOffset?: number;
  /** Pre-generated spectrogram image from wavesurfer */
  spectrogramImage?: ImageBitmap | null;
  /** Whether spectrogram is currently being generated by wavesurfer */
  spectrogramGenerating?: boolean;
  onSeek?: (timeInSeconds: number) => void;
  onZoomChange?: (zoom: number) => void;
  onScrollChange?: (scrollOffset: number) => void;
}

export const SpectralCanvas: React.FC<SpectralCanvasProps> = ({
  isLoaded,
  duration,
  zoom = 1,
  scrollOffset = 0,
  spectrogramImage,
  spectrogramGenerating = false,
  onSeek,
  onZoomChange,
  onScrollChange,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const timestamp = usePlayheadStore((state) => state.timestamp);
  const setTimestamp = usePlayheadStore((state) => state.setTimestamp);

  // Scrubbing state (drag playhead)
  const [isDragging, setIsDragging] = useState(false);
  const [isNearPlayhead, setIsNearPlayhead] = useState(false);

  // Spacebar + drag panning state
  const [isSpaceHeld, setIsSpaceHeld] = useState(false);
  const [isPanning, setIsPanning] = useState(false);
  const [panStartX, setPanStartX] = useState(0);
  const [panStartOffset, setPanStartOffset] = useState(0);

  // Draw Hz scale overlay on the left side
  const drawHzScale = useCallback((ctx: CanvasRenderingContext2D, _width: number, height: number) => {
    const scaleWidth = 50;

    // Translucent background gradient for better blending
    const bgGradient = ctx.createLinearGradient(0, 0, scaleWidth, 0);
    bgGradient.addColorStop(0, 'rgba(0, 0, 4, 0.85)');
    bgGradient.addColorStop(0.7, 'rgba(0, 0, 4, 0.7)');
    bgGradient.addColorStop(1, 'rgba(0, 0, 4, 0)');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, scaleWidth, height);

    // Frequency labels (logarithmic scale matching wavesurfer)
    const frequencies = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
    const labels = ['20', '50', '100', '200', '500', '1k', '2k', '5k', '10k', '20k'];

    ctx.font = '10px Inter, system-ui, sans-serif';
    ctx.textAlign = 'right';

    const logMin = Math.log10(20);
    const logMax = Math.log10(20000);

    frequencies.forEach((freq, i) => {
      const logFreq = Math.log10(freq);
      const ratio = (logFreq - logMin) / (logMax - logMin);
      const y = height - (ratio * height);

      // Skip if too close to edges
      if (y < 8 || y > height - 8) return;

      // Tick mark (subtle line extending into the spectrogram)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(scaleWidth - 5, y);
      ctx.lineTo(scaleWidth + 10, y);
      ctx.stroke();

      // Label
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillText(labels[i], scaleWidth - 8, y + 3);
    });

    // "Hz" unit label at bottom
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.font = '9px Inter, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Hz', 4, height - 4);
  }, []);

  // Draw dB scale overlay on the right side (color intensity legend)
  const drawDbScale = useCallback((ctx: CanvasRenderingContext2D, width: number, height: number) => {
    const scaleWidth = 50;
    const scaleX = width - scaleWidth;
    const barWidth = 12;
    const barX = scaleX + 8;

    // Translucent background gradient
    const bgGradient = ctx.createLinearGradient(scaleX, 0, width, 0);
    bgGradient.addColorStop(0, 'rgba(0, 0, 4, 0)');
    bgGradient.addColorStop(0.3, 'rgba(0, 0, 4, 0.7)');
    bgGradient.addColorStop(1, 'rgba(0, 0, 4, 0.85)');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(scaleX, 0, scaleWidth, height);

    // Draw color gradient bar showing the magma colormap
    const gradientBarHeight = height - 40;
    const gradientBarY = 20;
    const colorGradient = ctx.createLinearGradient(0, gradientBarY + gradientBarHeight, 0, gradientBarY);

    // Magma colormap stops (matching the spectrogram colors)
    colorGradient.addColorStop(0, 'rgb(0, 0, 4)');        // -60dB (silence)
    colorGradient.addColorStop(0.15, 'rgb(30, 12, 55)');  // Dark purple
    colorGradient.addColorStop(0.3, 'rgb(85, 30, 100)');  // Purple
    colorGradient.addColorStop(0.45, 'rgb(150, 50, 90)'); // Magenta
    colorGradient.addColorStop(0.6, 'rgb(210, 80, 50)');  // Orange-red
    colorGradient.addColorStop(0.75, 'rgb(245, 140, 35)');// Orange
    colorGradient.addColorStop(0.9, 'rgb(252, 210, 80)'); // Yellow
    colorGradient.addColorStop(1, 'rgb(255, 250, 200)');  // 0dB (peak)

    ctx.fillStyle = colorGradient;
    ctx.fillRect(barX, gradientBarY, barWidth, gradientBarHeight);

    // Border around the color bar
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, gradientBarY, barWidth, gradientBarHeight);

    // dB level labels
    const dbLevels = [0, -20, -40, -60];
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.font = '9px Inter, system-ui, sans-serif';
    ctx.textAlign = 'left';

    dbLevels.forEach(db => {
      // Map dB to y position (0dB = top, -60dB = bottom)
      const ratio = (db + 60) / 60;
      const y = gradientBarY + gradientBarHeight - (ratio * gradientBarHeight);

      // Small tick mark
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.beginPath();
      ctx.moveTo(barX + barWidth, y);
      ctx.lineTo(barX + barWidth + 4, y);
      ctx.stroke();

      // Label
      ctx.fillText(`${db}`, barX + barWidth + 6, y + 3);
    });

    // "dB" unit label
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.textAlign = 'right';
    ctx.fillText('dB', width - 4, height - 4);
  }, []);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    ctx.scale(dpr, dpr);

    const width = rect.width;
    const height = rect.height;

    // Clear canvas with dark background
    ctx.fillStyle = '#000004';
    ctx.fillRect(0, 0, width, height);

    if (!isLoaded) return;

    // Calculate visible time range
    const visibleDuration = duration / zoom;
    const startTime = scrollOffset * duration;

    // Draw spectrogram image if available
    if (spectrogramImage) {
      // Calculate source rectangle based on zoom/scroll
      const visibleFraction = 1 / zoom;
      const sourceX = Math.floor(scrollOffset * spectrogramImage.width);
      const sourceWidth = Math.ceil(spectrogramImage.width * visibleFraction);

      // Ensure we don't exceed image bounds
      const clampedSourceX = Math.max(0, Math.min(sourceX, spectrogramImage.width - 1));
      const clampedSourceWidth = Math.min(sourceWidth, spectrogramImage.width - clampedSourceX);

      // Enable image smoothing for better quality when scaling
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      // Draw the visible portion scaled to canvas
      ctx.drawImage(
        spectrogramImage,
        clampedSourceX, 0, clampedSourceWidth, spectrogramImage.height,
        0, 0, width, height
      );
    }
    // Note: If no spectrogramImage and spectrogramGenerating is true,
    // wavesurfer is rendering directly in its own container (visible to user)

    // Draw scale overlays (on top of spectrogram, below playhead)
    if (spectrogramImage || isLoaded) {
      drawHzScale(ctx, width, height);
      drawDbScale(ctx, width, height);
    }

    // Draw playhead
    if (duration > 0) {
      const playheadTime = timestamp / 1000;
      const playheadX = ((playheadTime - startTime) / visibleDuration) * width;

      if (playheadX >= 0 && playheadX <= width) {
        ctx.shadowColor = '#19abb5';
        ctx.shadowBlur = 8;

        ctx.strokeStyle = '#19abb5';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(playheadX, 0);
        ctx.lineTo(playheadX, height);
        ctx.stroke();

        ctx.shadowBlur = 0;

        // Triangle at top
        ctx.fillStyle = '#19abb5';
        ctx.beginPath();
        ctx.moveTo(playheadX - 6, 0);
        ctx.lineTo(playheadX + 6, 0);
        ctx.lineTo(playheadX, 8);
        ctx.closePath();
        ctx.fill();
      }
    }
  }, [isLoaded, duration, zoom, scrollOffset, timestamp, spectrogramImage, drawHzScale, drawDbScale]);

  useEffect(() => {
    draw();
  }, [draw]);

  // ResizeObserver for container size changes
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const resizeObserver = new ResizeObserver(() => {
      draw();
    });

    resizeObserver.observe(container);

    return () => resizeObserver.disconnect();
  }, [draw]);

  // Helper to check if mouse is near playhead
  const checkNearPlayhead = useCallback((e: React.MouseEvent) => {
    if (!canvasRef.current || duration <= 0) return false;

    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;

    const visibleDuration = duration / zoom;
    const startTime = scrollOffset * duration;
    const playheadX = ((timestamp / 1000 - startTime) / visibleDuration) * rect.width;

    return Math.abs(mouseX - playheadX) < 10;
  }, [duration, zoom, scrollOffset, timestamp]);

  // Seek to position helper
  const seekToPosition = useCallback((e: React.MouseEvent) => {
    if (!canvasRef.current || duration <= 0) return;

    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const clickRatio = Math.max(0, Math.min(1, mouseX / rect.width));

    const visibleDuration = duration / zoom;
    const startTime = scrollOffset * duration;
    const clickTime = startTime + (clickRatio * visibleDuration);

    setTimestamp(clickTime * 1000);
    onSeek?.(clickTime);
  }, [duration, zoom, scrollOffset, setTimestamp, onSeek]);

  // Mouse handlers for scrubbing and panning
  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isLoaded || duration <= 0) return;

    // Spacebar held = start panning
    if (isSpaceHeld && zoom > 1) {
      setIsPanning(true);
      setPanStartX(e.clientX);
      setPanStartOffset(scrollOffset);
      return;
    }

    // Near playhead = start scrubbing
    if (checkNearPlayhead(e)) {
      setIsDragging(true);
      return;
    }

    // Otherwise click to seek
    seekToPosition(e);
  }, [isLoaded, duration, isSpaceHeld, zoom, scrollOffset, checkNearPlayhead, seekToPosition]);

  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    // Panning
    if (isPanning && canvasRef.current && onScrollChange) {
      const rect = canvasRef.current.getBoundingClientRect();
      const deltaX = e.clientX - panStartX;
      const deltaRatio = deltaX / rect.width;
      const visibleFraction = 1 / zoom;

      const newOffset = Math.max(0, Math.min(1 - visibleFraction,
        panStartOffset - deltaRatio * visibleFraction));
      onScrollChange(newOffset);
      return;
    }

    // Update cursor based on proximity to playhead
    if (!isSpaceHeld) {
      setIsNearPlayhead(checkNearPlayhead(e));
    }

    // Scrubbing
    if (isDragging) {
      seekToPosition(e);
    }
  }, [isPanning, panStartX, panStartOffset, zoom, onScrollChange, isSpaceHeld, checkNearPlayhead, isDragging, seekToPosition]);

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
    setIsPanning(false);
  }, []);

  const handleMouseLeave = useCallback(() => {
    setIsDragging(false);
    setIsPanning(false);
    setIsNearPlayhead(false);
  }, []);

  // Wheel zoom handler
  const handleWheel = useCallback((e: React.WheelEvent) => {
    if (!isLoaded || duration <= 0 || !onZoomChange || !onScrollChange) return;
    e.preventDefault();

    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(1, Math.min(10, zoom * zoomFactor));

    // Center zoom on playhead
    const playheadTime = timestamp / 1000;
    const newVisibleDuration = duration / newZoom;
    const newScrollOffset = Math.max(0, Math.min(1 - 1 / newZoom,
      (playheadTime - newVisibleDuration / 2) / duration));

    onZoomChange(newZoom);
    onScrollChange(newScrollOffset);
  }, [isLoaded, duration, zoom, timestamp, onZoomChange, onScrollChange]);

  // Spacebar keyboard listener for panning
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.code === 'Space' && !e.repeat) {
        e.preventDefault();
        setIsSpaceHeld(true);
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.code === 'Space') {
        setIsSpaceHeld(false);
        setIsPanning(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Determine cursor based on state
  const getCursor = () => {
    if (isPanning) return 'grabbing';
    if (isSpaceHeld) return 'grab';
    if (isNearPlayhead || isDragging) return 'ew-resize';
    if (isLoaded) return 'crosshair';
    return 'default';
  };

  return (
    <Box ref={containerRef} sx={{ width: '100%', height: '100%', position: 'relative' }}>
      <canvas
        ref={canvasRef}
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseLeave}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          cursor: getCursor(),
          // Hide canvas while wavesurfer is generating (wavesurfer renders in its own container)
          opacity: spectrogramGenerating ? 0 : 1,
        }}
      />
    </Box>
  );
};

export default SpectralCanvas;
